#include "tagset.h"

#include <libtoki/foreach.h>

#include <boost/algorithm/string.hpp>
#include <boost/strong_typedef.hpp>
#include <boost/algorithm/string.hpp>

#include <sstream>
#include <iostream>

namespace PlTagger {

	Tagset::Tagset()
	{
	}

	std::string TagsetParseError::info() const
	{
		std::stringstream ss;
		ss << "Line " << line << ": " << what() << " " << data;
		return ss.str();
	}


	void Tagset::load_from_stream(std::istream &is)
	{
		int line_no = 0;
		std::string line;
		std::string sep(" \t=");
		std::set<std::string> values;
		values.insert("@null");
		std::set<std::string> symbols(values);
		typedef std::map< std::string, std::deque<std::string> > vmap_t;
		vmap_t vmap;
		typedef std::map< std::string, std::vector<attribute_idx_t> > pmap_t;
		pmap_t pmap;
		typedef std::map< std::string, std::vector<bool> > reqmap_t;
		reqmap_t reqmap;

		while (is.good() && line != "[ATTR]") {
			std::getline(is, line);
			boost::algorithm::trim(line);
			++line_no;
		}
		std::getline(is, line);
		boost::algorithm::trim(line);
		++line_no;

		//attribute-value defs
		while (is.good() && line != "[POS]") {
			if (!line.empty() && line[0] != '#') {
				std::deque<std::string> v;
				boost::algorithm::split(v, line, boost::is_any_of(sep),
						boost::algorithm::token_compress_on);
				if (v.size() < 3) {
					throw TagsetParseError("Attribute with less than 2 values", line_no, v[0]);
				}
				if (!symbols.insert(v[0]).second) {
					throw TagsetParseError("Duplicate symbol", line_no, v[0]);
				}
				std::deque<std::string>& avalues = vmap[v[0]];
				v.pop_front();
				avalues = v;
				foreach (const std::string& s, v) {
					if (!values.insert(s).second) {
						throw TagsetParseError("Duplicate symbol", line_no, s);
					}
				}
			}
			std::getline(is, line);
			boost::algorithm::trim(line);
			++line_no;
		}
		std::getline(is, line);
		boost::algorithm::trim(line);
		++line_no;

		std::vector<std::string> vec;
		std::copy(values.begin(), values.end(), std::inserter(vec, vec.begin()));
		if (vec[0] != "@null") {
			throw TagsetParseError("First value is not '@null'", line_no, vec[0]);
		}
		value_dict_.load_sorted_data(vec);

		vec.clear();
		foreach (const vmap_t::value_type v, vmap) {
			vec.push_back(v.first);
			attribute_values_.resize(attribute_values_.size() + 1);
			foreach (const std::string& s, v.second) {
				attribute_values_.back().push_back(value_dict_.get_id(s));
			}
		}
		attribute_dict_.load_sorted_data(vec);

		while (is.good()) {
			if (!line.empty() && line[0] != '#') {
				std::deque<std::string> v;
				boost::algorithm::split(v, line, boost::is_any_of(sep),
						boost::algorithm::token_compress_on);
				if (!symbols.insert(v[0]).second) {
					throw TagsetParseError("Duplicate symbol", line_no, v[0]);
				}
				std::vector<attribute_idx_t>& pattrs = pmap[v[0]];
				std::vector<bool>& req_mask = reqmap[v[0]];
				v.pop_front();
				foreach (std::string s, v) {
					if (s.empty()) continue;
					bool required = true;
					if (s[0] == '[' && s[s.size() - 1] == ']') {
						required = false;
						s = s.substr(1, s.size() - 2);
					}
					attribute_idx_t a = attribute_dict_.get_id(s);
					if (!attribute_dict_.is_id_valid(a)) {
						throw TagsetParseError("Attribute name invalid", line_no, s);
					}
					pattrs.push_back(a);
					req_mask[a] = required;
				}
			}
			std::getline(is, line);
			boost::algorithm::trim(line);
			++line_no;
		}

		vec.clear();
		foreach (const pmap_t::value_type v, pmap) {
			vec.push_back(v.first);
			pos_attributes_.push_back(v.second);
			pos_valid_attributes_.push_back(std::vector<bool>(attribute_values_.size(), false));
			foreach (attribute_idx_t a, v.second) {
				pos_valid_attributes_.back()[a] = true;
			}
			pos_required_attributes_.push_back(reqmap[v.first]);
		}
		pos_dict_.load_sorted_data(vec);
	}

	void Tagset::save_to_stream(std::ostream &os)
	{
		os << "# Autogenerated by PlTagger\n\n";
		os << "[ATTR]\n";
		attribute_idx_t a(0);
		while (attribute_dict_.is_id_valid(a)) {
			os << attribute_dict_.get_string(a) << "\t= ";
			foreach (value_idx_t v, get_attribute_values(a)) {
				os << value_dict_.get_string(v) << " ";
			}
			os << "\n";
			++a;
		}
		os << "\n[POS]\n";
		pos_idx_t p(0);
		while (pos_dict_.is_id_valid(p)) {
			os << pos_dict_.get_string(p) << "\t= ";
			foreach (attribute_idx_t a, get_pos_attributes(p)) {
				if (pos_required_attributes_[p][a]) {
					os << attribute_dict_.get_string(a) << " ";
				} else {
					os << '[' << attribute_dict_.get_string(a) << "] ";
				}
			}
			os << "\n";
			++p;
		}
		os << "# End autogenerated file\n";
	}

	Tag Tagset::parse_tag(const std::string &s, bool allow_extra) const
	{
		tstring_ranges fields;
		boost::algorithm::split(fields, s, boost::is_any_of(std::string(":")));
		return parse_tag(fields, allow_extra);
	}

	Tag Tagset::parse_tag(const tstring_ranges &ts, bool allow_extra) const
	{
		if (ts.empty()) throw TagParseError("Empty POS+attribute list");
		//const std::string& pos_str = boost::copy_range<std::string>(ts[0]);

		pos_idx_t pos_id = pos_dict_.get_id(ts[0]);

		if (!pos_dict_.is_id_valid(pos_id)) {
			throw TagParseError("Invalid POS");
		}

		const std::vector<bool>& valid_attrs_mask = get_pos_valid_attributes(pos_id);

		Tag tag(id_, pos_id);

		for (size_t i = 1; i < ts.size(); ++i) {
			value_idx_t val_id = value_dict_.get_id(ts[i]);
			if (!value_dict_.is_id_valid(val_id)) {
				throw TagParseError("Unknown attribute value");
			}

			attribute_idx_t attr_id = get_value_attribute(val_id);

			if (valid_attrs_mask[attr_id] || allow_extra) {
				tag.values()[attr_id] = val_id;
			}
		}

		return tag;
	}

	bool Tagset::validate_tag(const Tag &t, bool allow_extra)
	{
		if (pos_dict_.is_id_valid(t.pos_id())) return false;
		std::vector<bool> valid = get_pos_valid_attributes(t.pos_id());
		std::vector<bool> required = get_pos_required_attributes(t.pos_id());
		if (t.values().size() < attribute_dict_.size()) return false;
		if (!allow_extra && t.values().size() > attribute_dict_.size()) return false;
		for (size_t i = 0; i < t.values().size(); ++i) {
			value_idx_t v = t.values()[i];
			if (v == 0) {
				if (required[i]) return false;
			} else {
				if (!valid[i] && !allow_extra) return false;
				if (!value_dict_.is_id_valid(v)) return false;
				attribute_idx_t a = value_attribute_[v];
				if (a != static_cast<attribute_idx_t>(i)) return false;
			}
		}
		return true;
	}

	std::string Tagset::tag_to_string(const Tag &tag) const
	{
		std::ostringstream ss;
		ss << pos_dict_.get_string(tag.pos_id());
		const std::vector<attribute_idx_t>& attrs = get_pos_attributes(tag.pos_id());
		foreach (const attribute_idx_t& a, attrs) {
			ss << ":";
			ss << value_dict_.get_string(tag.values()[a]);
		}
		return ss.str();
	}


	attribute_idx_t Tagset::get_value_attribute(value_idx_t id) const
	{
		assert(value_dict_.is_id_valid(id));
		return value_attribute_[id];
	}

	const std::vector<value_idx_t>& Tagset::get_attribute_values(attribute_idx_t a) const
	{
		assert(attribute_dict_.is_id_valid(a));
		return attribute_values_[a];
	}

	const std::vector<attribute_idx_t>& Tagset::get_pos_attributes(pos_idx_t pos) const
	{
		assert(pos_dict_.is_id_valid(pos));
		return pos_attributes_[pos];
	}

	const std::vector<bool>& Tagset::get_pos_valid_attributes(pos_idx_t pos) const
	{
		assert(pos_dict_.is_id_valid(pos));
		return pos_valid_attributes_[pos];
	}

	const std::vector<bool>& Tagset::get_pos_required_attributes(pos_idx_t pos) const
	{
		assert(pos_dict_.is_id_valid(pos));
		return pos_required_attributes_[pos];
	}

} /* end ns PlTagger */
